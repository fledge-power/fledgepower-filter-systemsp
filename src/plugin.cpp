/*
 * Fledge filter mvcyclingcheck.
 *
 * Copyright (c) 2020, RTE (https://www.rte-france.com)
 *
 * Released under the Apache 2.0 Licence
 *
 * Author: Yannick Marchetaux
 * 
 */
#include <version.h>
#include <plugin_api.h>

#include "ruleSystemSp.h"
#include "constantsSystem.h"

using namespace systemspr;

static const char *default_config = QUOTE({
		"plugin" : {
			"description" : "Notification rule plugin that sends a notifications when a system status point reading should be created",
            "type" : "string",
			"default" : FILTER_NAME,
			"readonly" : "true"
			},
		"enable": {
			"description": "A switch that can be used to enable or disable execution of the filter.",
			"displayName": "Enabled",
			"type": "boolean",
			"default": "true"
			},
		"asset": {
			"description" : "The name of the asset containing south_event readings to monitor",
			"displayName" : "Asset name",
			"type" : "string",
			"default" : "CONNECTION-1"
		    },
		"exchanged_data" : {
			"description" : "exchanged data list",
			"type" : "JSON",
			"displayName" : "Exchanged data list",
			"order" : "3",
			"default" : QUOTE({
				"exchanged_data": {         
					"datapoints" : [          
						{
							"label":"TS-1",
							"pivot_id":"M_2367_3_15_4",
							"pivot_type":"SpsTyp",
							"pivot_subtypes": [
								"acces"
							],
							"ts_syst_cycle" :30,
							"protocols":[
								{
									"name":"IEC104",
									"typeid":"M_ME_NC_1",
									"address":"3271612"
								}
							]
						},
						{
							"label":"TS-2",
							"pivot_id":"M_2367_3_15_5",
							"pivot_type":"DpsTyp",
							"pivot_subtypes": [
								"prt.inf"
							],
							"protocols":[
								{
									"name":"IEC104",
									"typeid":"M_ME_NC_1",
									"address":"3271612"
								}
							]
						}
					]
				}
			})
   		}
	});

/**
 * The Filter plugin interface
 */
extern "C" {

/**
 * The plugin information structure
 */
static PLUGIN_INFORMATION info = {
        FILTER_NAME, 			       // Name
		VERSION,				       // Version
        0,                             // Flags
        PLUGIN_TYPE_NOTIFICATION_RULE, // Type
        "1.0.0",                       // Interface version
		default_config	                // Default plugin configuration
};

/**
 * Return the information about this plugin
 */
PLUGIN_INFORMATION *plugin_info() {
	return &info;
}

/**
 * Initialise the plugin, called to get the plugin handle and setup the
 * output handle that will be passed to the output stream. The output stream
 * is merely a function pointer that is called with the output handle and
 * the new set of readings generated by the plugin.
 *     (*output)(outHandle, readings);
 *
 * @param config	The configuration category for the filter
 * @param outHandle	A handle that will be passed to the output stream
 * @param output	The output stream (function pointer) to which data is passed
 * @return		An opaque handle that is used in all subsequent calls to the plugin
 */
PLUGIN_HANDLE plugin_init(ConfigCategory* config)
{
	auto ruleSystemSp = new RuleSystemSp();
 	ruleSystemSp->reconfigure(*config);
	return (PLUGIN_HANDLE)ruleSystemSp;
}

/**
 * Return triggers JSON document
 *
 * @return	JSON string
 */
std::string plugin_triggers(PLUGIN_HANDLE handle)
{
	auto ruleSystemSp = (RuleSystemSp *)handle;
	return ruleSystemSp->getTriggers();
}


/**
 * Evaluate notification data received
 *
 *  If no assets found or asset time difference is not in time frame,
 *  then return TRUE
 *
 * @param    assetValues	JSON string document
 *				with notification data.
 * @return			True if the rule was triggered,
 *				false otherwise.
 */
bool plugin_eval(PLUGIN_HANDLE handle, const std::string& assetValues)
{
	auto ruleSystemSp = (RuleSystemSp *)handle;
	return ruleSystemSp->evalRule(assetValues);
}

/**
 * Return rule trigger reason: trigger or clear the notification. 
 *
 * @return	 A JSON string
 */
std::string plugin_reason(PLUGIN_HANDLE handle)
{
	auto ruleSystemSp = (RuleSystemSp *)handle;
	return ruleSystemSp->getReason();
}

/**
 * Plugin reconfiguration entry point
 *
 * @param	handle	The plugin handle
 * @param	newConfig	The new configuration data
 */
void plugin_reconfigure(PLUGIN_HANDLE *handle, const std::string& newConfig)
{
	auto ruleSystemSp = (RuleSystemSp *)handle;
	ConfigCategory	config("newConfig", newConfig);
	ruleSystemSp->reconfigure(config);
}

/**
 * Call the shutdown method in the plugin
 */
void plugin_shutdown(PLUGIN_HANDLE *handle)
{
	auto ruleSystemSp = (RuleSystemSp *)handle;
	delete ruleSystemSp;
}

// End of extern "C"
};

